Mühle-Engine & Trainingsmodus – Zusammenfassung für Refactoring & Abstimmung
1) Zielbild (klar priorisiert)

Primäres Ziel:

Lernen & Analyse („Züge vorausdenken“, warum ein Zug gut/schlecht ist)

Sekundäres Ziel:

Spielstarker Computergegner (produktfähig, später erweiterbar)

Konsequenz:
→ Klassische Engine (Minimax + Alpha-Beta) statt ML/RL
→ Maximale Erklärbarkeit + gute Spielstärke

2) Architektur-Entscheidung (Refactoring-relevant)
Saubere Trennung

Frontend (Streamlit/UI):

Visualisierung

Interaktion

Anzeige von Analyse, PV, Erklärungen

kennt keine Suchlogik

Backend (Engine/Core):

Spielregeln

Zugerzeugung

Suche & Bewertung

vollständig UI-agnostisch

Empfohlene Ordnerstruktur
core/
  state.py        # State, Move, Phase, Player
  rules.py        # Legal moves, mills, terminal checks

engine/
  search.py       # Minimax, Alpha-Beta, Iterative Deepening, TT
  eval.py         # Evaluation + Breakdown + Threats
  hash.py         # Transposition Table Hashing (+ optional Symmetrien)

ui/
  streamlit_app.py
  components/


→ Refactoring jetzt sinnvoll, bevor Search/Analyse tief integriert wird.

3) Engine-Grundlage (technisch)
Algorithmus

Minimax mit Alpha-Beta-Pruning

Iterative Deepening (zeitbasiert, z. B. 300–800 ms)

Transposition Table (TT)

Move Ordering

Mill-Züge zuerst

Captures/Removes

Blocking Moves

TT-Bestmove (optional)

Warum das ideal ist

Hohe Spielstärke bei moderatem Aufwand

Deterministisch & testbar

Jede Entscheidung ist erklärbar

Perfekt für Trainings-/Analysemodus

4) Such-API (Guardrails für die Codebase)

Minimal notwendige öffentliche Schnittstellen:

engine.analyze(state, limits) -> AnalysisResult
engine.best_move(state, limits) -> Move


AnalysisResult enthält:

Best Move + Score

erreichte Tiefe

Knotenanzahl

Principal Variation (PV)

Top-N Züge

Eval-Breakdown

Threat-Report

UI konsumiert nur das.

5) Bewertungsfunktion (zentrales Lerninstrument)
Tier-1-Features (Pflicht)

Material (Steine auf Brett / in Hand)

Mobilität (Anzahl legaler Züge)

bestehende Mühlen

offene Mühlen

Mill-in-1-Drohungen

Blockierte gegnerische Steine

Tier-2-Features (stark)

Double Threats (mehrere offene Mühlen)

Initiative / Zwangszüge

Positions-Konnektivität (hochvernetzte Felder)

Wichtig

Evaluation liefert nicht nur einen Score, sondern:

breakdown(): Dict[str, float]

Differenzen vor/nach einem Zug

→ Grundlage für „Warum ist das schlecht/gut?“

6) Engine-Erklärungen (für Lernmodus)
Drei Ebenen der Erklärung

Move Ranking

Top-5 Züge mit Score

Differenz zum Best Move

Klassifikation:

Best / Good / Inaccuracy / Mistake / Blunder

Principal Variation

Konkrete Folge optimaler Züge

„Wenn du X spielst, antwortet Y, dann Z …“

Why-Panel

Eval-Feature-Änderungen (z. B. −Mobilität, +Open-Mill)

Taktische Hinweise:

„Du erlaubst eine Mühle in 1“

„Du verpasst eine doppelte Drohung“

„Dieser Stein ist danach gefangen“

7) Symmetrien & Performance (Mühle-Spezialvorteil)
Problem

Viele Brettstellungen sind:

identisch unter Rotation (90°/180°/270°)

identisch unter Spiegelung

Lösung

Kanonisches Hashing:

alle 8 Symmetrien berechnen

lexikographisch kleinste Board-Repräsentation verwenden

Side-to-move & Phase in Hash einbeziehen

Empfehlung für jetzt

Symmetrie nur für TT-Score-Caching

keine Best-Move-Speicherung in TT bei Symmetrie
→ deutlich einfacher & sicher

(Upgrade später möglich)

8) Move-Handling (wichtig für Search)

Züge als Composite Moves modellieren:

Place / Move / Fly inkl. Remove

Jede Suchkante = vollständig abgeschlossener Halbzug

Kein „nachträgliches Remove“ im Search

→ vereinfacht Minimax massiv

9) Konkrete To-Dos für uns (nächster Sprint)

Refactoring

State/Move/Rules isolieren

Engine als eigenes Modul

Move Generator finalisieren

alle Phasen korrekt

Mill + Remove als ein Zug

Alpha-Beta + Iterative Deepening

Zeitbudget

TT ohne Symmetrie oder mit Score-Only-Symmetrie

Evaluation v1

Tier-1-Features

Breakdown-Output

Analyse-API anbinden

Best Move

Top-Moves

PV

Why-Panel